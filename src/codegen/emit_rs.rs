use crate::types::ToolDefinition;
use std::fmt::Write;

/// Generate Rust type definitions and a typed client from MCP tool schemas.
pub fn emit_rust_types(tools: &[ToolDefinition], server_name: &str) -> String {
    let mut out = String::new();

    // File header
    writeln!(out, "// Auto-generated by mcplug. Do not edit.").unwrap();
    writeln!(out).unwrap();
    writeln!(out, "use serde::{{Deserialize, Serialize}};").unwrap();
    writeln!(out).unwrap();

    // Generate structs for each tool's input schema
    for tool in tools {
        let struct_name = format!("{}Args", to_pascal_case(&tool.name));
        emit_struct(&mut out, &struct_name, &tool.input_schema, 0);
        writeln!(out).unwrap();
    }

    // Generate the client struct
    let client_name = format!("{}Client", to_pascal_case(server_name));
    writeln!(out, "#[derive(Debug, Clone)]").unwrap();
    writeln!(out, "pub struct {client_name} {{").unwrap();
    writeln!(out, "    runtime: mcplug::Runtime,").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out).unwrap();
    writeln!(out, "impl {client_name} {{").unwrap();
    writeln!(
        out,
        "    pub fn new(runtime: mcplug::Runtime) -> Self {{"
    )
    .unwrap();
    writeln!(out, "        Self {{ runtime }}").unwrap();
    writeln!(out, "    }}").unwrap();

    for tool in tools {
        let method_name = to_snake_case(&tool.name);
        let args_type = format!("{}Args", to_pascal_case(&tool.name));
        writeln!(out).unwrap();
        writeln!(
            out,
            "    pub async fn {method_name}(&self, args: {args_type}) -> Result<mcplug::CallResult, mcplug::McplugError> {{"
        )
        .unwrap();
        writeln!(
            out,
            "        self.runtime.call_tool(\"{server}\", \"{tool}\", serde_json::to_value(args).unwrap()).await",
            server = server_name,
            tool = tool.name,
        )
        .unwrap();
        writeln!(out, "    }}").unwrap();
    }

    writeln!(out, "}}").unwrap();
    out
}

fn emit_struct(out: &mut String, name: &str, schema: &serde_json::Value, depth: usize) {
    let indent = "    ".repeat(depth);
    writeln!(out, "{indent}#[derive(Debug, Clone, Serialize, Deserialize)]").unwrap();
    writeln!(out, "{indent}pub struct {name} {{").unwrap();

    let required = schema
        .get("required")
        .and_then(|v| v.as_array())
        .map(|arr| {
            arr.iter()
                .filter_map(|v| v.as_str())
                .map(String::from)
                .collect::<Vec<_>>()
        })
        .unwrap_or_default();

    if let Some(props) = schema.get("properties").and_then(|v| v.as_object()) {
        for (prop_name, prop_schema) in props {
            let field_name = sanitize_identifier(&to_snake_case(prop_name));
            let rust_type = json_schema_to_rust_type(prop_schema);

            // Add serde rename if the field name differs from the original
            if field_name != *prop_name {
                writeln!(
                    out,
                    "{indent}    #[serde(rename = \"{prop_name}\")]"
                )
                .unwrap();
            }

            if required.contains(prop_name) {
                writeln!(out, "{indent}    pub {field_name}: {rust_type},").unwrap();
            } else {
                writeln!(out, "{indent}    pub {field_name}: Option<{rust_type}>,").unwrap();
            }
        }
    }

    writeln!(out, "{indent}}}").unwrap();
}

/// Convert a JSON Schema type description to a Rust type string.
pub fn json_schema_to_rust_type(schema: &serde_json::Value) -> String {
    match schema.get("type").and_then(|v| v.as_str()) {
        Some("string") => "String".to_string(),
        Some("number") => "f64".to_string(),
        Some("integer") => "i64".to_string(),
        Some("boolean") => "bool".to_string(),
        Some("array") => {
            let item_type = schema
                .get("items")
                .map(json_schema_to_rust_type)
                .unwrap_or_else(|| "serde_json::Value".to_string());
            format!("Vec<{item_type}>")
        }
        Some("object") => {
            if schema.get("properties").is_some() {
                // Nested object with known properties â€” would need a named struct.
                // For simplicity in inline usage, use Value.
                "serde_json::Value".to_string()
            } else {
                "serde_json::Value".to_string()
            }
        }
        Some("null") => "()".to_string(),
        _ => "serde_json::Value".to_string(),
    }
}

/// Sanitize a string to be a valid Rust identifier.
pub fn sanitize_identifier(name: &str) -> String {
    let mut result = String::with_capacity(name.len());
    for (i, ch) in name.chars().enumerate() {
        if ch.is_ascii_alphanumeric() || ch == '_' {
            result.push(ch);
        } else {
            result.push('_');
        }
        // Ensure it doesn't start with a digit
        if i == 0 && ch.is_ascii_digit() {
            let mut prefixed = String::from("_");
            prefixed.push_str(&result);
            result = prefixed;
        }
    }
    if result.is_empty() {
        return "_unnamed".to_string();
    }
    // Avoid Rust keywords
    match result.as_str() {
        "type" | "struct" | "enum" | "fn" | "let" | "mut" | "ref" | "self" | "super" | "crate"
        | "use" | "mod" | "pub" | "return" | "match" | "if" | "else" | "loop" | "while"
        | "for" | "in" | "as" | "impl" | "trait" | "where" | "async" | "await" | "move"
        | "dyn" | "static" | "const" | "unsafe" | "extern" | "true" | "false" | "break"
        | "continue" | "yield" => {
            result.push('_');
        }
        _ => {}
    }
    result
}

/// Convert a string to PascalCase.
pub fn to_pascal_case(name: &str) -> String {
    name.split(|c: char| c == '-' || c == '_' || c == '.' || c == ' ')
        .filter(|s| !s.is_empty())
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                Some(first) => {
                    let mut s = first.to_uppercase().to_string();
                    s.extend(chars);
                    s
                }
                None => String::new(),
            }
        })
        .collect()
}

/// Convert a string to snake_case.
pub fn to_snake_case(name: &str) -> String {
    let mut result = String::with_capacity(name.len() + 4);
    let mut prev_was_upper = false;
    let mut prev_was_separator = false;

    for (i, ch) in name.chars().enumerate() {
        if ch == '-' || ch == '.' || ch == ' ' {
            if !result.is_empty() && !prev_was_separator {
                result.push('_');
            }
            prev_was_separator = true;
            prev_was_upper = false;
            continue;
        }
        if ch == '_' {
            if !result.is_empty() && !prev_was_separator {
                result.push('_');
            }
            prev_was_separator = true;
            prev_was_upper = false;
            continue;
        }
        if ch.is_uppercase() {
            if i > 0 && !prev_was_upper && !prev_was_separator {
                result.push('_');
            }
            result.push(ch.to_lowercase().next().unwrap());
            prev_was_upper = true;
        } else {
            result.push(ch);
            prev_was_upper = false;
        }
        prev_was_separator = false;
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::ToolDefinition;

    #[test]
    fn test_to_pascal_case() {
        assert_eq!(to_pascal_case("hello-world"), "HelloWorld");
        assert_eq!(to_pascal_case("my_tool"), "MyTool");
        assert_eq!(to_pascal_case("simple"), "Simple");
        assert_eq!(to_pascal_case("a.b.c"), "ABC");
        assert_eq!(to_pascal_case("already_Pascal"), "AlreadyPascal");
    }

    #[test]
    fn test_to_snake_case() {
        assert_eq!(to_snake_case("helloWorld"), "hello_world");
        assert_eq!(to_snake_case("MyTool"), "my_tool");
        assert_eq!(to_snake_case("simple"), "simple");
        assert_eq!(to_snake_case("kebab-case"), "kebab_case");
        assert_eq!(to_snake_case("with.dots"), "with_dots");
        assert_eq!(to_snake_case("already_snake"), "already_snake");
    }

    #[test]
    fn test_sanitize_identifier() {
        assert_eq!(sanitize_identifier("normal"), "normal");
        assert_eq!(sanitize_identifier("kebab-case"), "kebab_case");
        assert_eq!(sanitize_identifier("with spaces"), "with_spaces");
        assert_eq!(sanitize_identifier("123start"), "_123start");
        assert_eq!(sanitize_identifier("type"), "type_");
        assert_eq!(sanitize_identifier(""), "_unnamed");
        assert_eq!(sanitize_identifier("hello!world"), "hello_world");
    }

    #[test]
    fn test_json_schema_to_rust_type_string() {
        let schema = serde_json::json!({"type": "string"});
        assert_eq!(json_schema_to_rust_type(&schema), "String");
    }

    #[test]
    fn test_json_schema_to_rust_type_number() {
        let schema = serde_json::json!({"type": "number"});
        assert_eq!(json_schema_to_rust_type(&schema), "f64");
    }

    #[test]
    fn test_json_schema_to_rust_type_integer() {
        let schema = serde_json::json!({"type": "integer"});
        assert_eq!(json_schema_to_rust_type(&schema), "i64");
    }

    #[test]
    fn test_json_schema_to_rust_type_boolean() {
        let schema = serde_json::json!({"type": "boolean"});
        assert_eq!(json_schema_to_rust_type(&schema), "bool");
    }

    #[test]
    fn test_json_schema_to_rust_type_array() {
        let schema = serde_json::json!({"type": "array", "items": {"type": "string"}});
        assert_eq!(json_schema_to_rust_type(&schema), "Vec<String>");
    }

    #[test]
    fn test_json_schema_to_rust_type_array_no_items() {
        let schema = serde_json::json!({"type": "array"});
        assert_eq!(json_schema_to_rust_type(&schema), "Vec<serde_json::Value>");
    }

    #[test]
    fn test_json_schema_to_rust_type_object() {
        let schema = serde_json::json!({"type": "object"});
        assert_eq!(json_schema_to_rust_type(&schema), "serde_json::Value");
    }

    #[test]
    fn test_json_schema_to_rust_type_unknown() {
        let schema = serde_json::json!({});
        assert_eq!(json_schema_to_rust_type(&schema), "serde_json::Value");
    }

    #[test]
    fn test_emit_rust_types_basic() {
        let tools = vec![ToolDefinition {
            name: "get-weather".to_string(),
            description: "Get weather for a location".to_string(),
            input_schema: serde_json::json!({
                "type": "object",
                "properties": {
                    "location": {"type": "string"},
                    "units": {"type": "string"}
                },
                "required": ["location"]
            }),
        }];

        let output = emit_rust_types(&tools, "weather-api");
        assert!(output.contains("pub struct GetWeatherArgs"));
        assert!(output.contains("pub location: String"));
        assert!(output.contains("pub units: Option<String>"));
        assert!(output.contains("pub struct WeatherApiClient"));
        assert!(output.contains("async fn get_weather"));
        assert!(output.contains("#[derive(Debug, Clone, Serialize, Deserialize)]"));
    }

    #[test]
    fn test_emit_rust_types_multiple_tools() {
        let tools = vec![
            ToolDefinition {
                name: "list_files".to_string(),
                description: "List files".to_string(),
                input_schema: serde_json::json!({
                    "type": "object",
                    "properties": {
                        "path": {"type": "string"}
                    },
                    "required": ["path"]
                }),
            },
            ToolDefinition {
                name: "read_file".to_string(),
                description: "Read a file".to_string(),
                input_schema: serde_json::json!({
                    "type": "object",
                    "properties": {
                        "path": {"type": "string"},
                        "encoding": {"type": "string"}
                    },
                    "required": ["path"]
                }),
            },
        ];

        let output = emit_rust_types(&tools, "fs");
        assert!(output.contains("pub struct ListFilesArgs"));
        assert!(output.contains("pub struct ReadFileArgs"));
        assert!(output.contains("pub struct FsClient"));
        assert!(output.contains("async fn list_files"));
        assert!(output.contains("async fn read_file"));
    }

    #[test]
    fn test_emit_rust_types_complex_schema() {
        let tools = vec![ToolDefinition {
            name: "search".to_string(),
            description: "Search".to_string(),
            input_schema: serde_json::json!({
                "type": "object",
                "properties": {
                    "query": {"type": "string"},
                    "max_results": {"type": "integer"},
                    "tags": {"type": "array", "items": {"type": "string"}},
                    "verbose": {"type": "boolean"},
                    "score_threshold": {"type": "number"}
                },
                "required": ["query"]
            }),
        }];

        let output = emit_rust_types(&tools, "search-engine");
        assert!(output.contains("pub query: String"));
        assert!(output.contains("pub max_results: Option<i64>"));
        assert!(output.contains("pub tags: Option<Vec<String>>"));
        assert!(output.contains("pub verbose: Option<bool>"));
        assert!(output.contains("pub score_threshold: Option<f64>"));
    }
}
